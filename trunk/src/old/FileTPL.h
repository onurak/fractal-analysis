#ifndef FILEPAT_H
#define FILEPAT_H

#include <string>
#include "Pattern.h"
#include "AbstractParser.h"
#include "Guards.h"
#include "Terms.h"

namespace FL {

/*! \addtogroup FLFiles
  */
/*@{*/

const int LEX_GUARD = 1; // @
const int LEX_INDEXED_TERM = 2; // name_42, в стеке лексем записывается как LEX_INDEXED_TERM LEX_INT

/*! \class FilePAT
  * \brief Чтение из PAT-файлов - файлов, содержащих шаблоны FL
  *
  * О теоретической части описания шаблонов подробно написано в курсовой.
  * Формат PAT-файла (в форме БНФ):
  * \code
  * <name> ::= <letter>{(<letter | <number>)}
  * <file> ::= {<file_record>}
  * <file_record> ::= <bnf> [@ <guard>] ";"
  * <uint> ::= <number>{<number>}
  * <indexed> ::= <name>"_"<uint>
  * <bnf> ::= <name> "=" <indexed> { <indexed> } { [ "|" <bnf> | "(" <bnf> ")" | "{" <bnf> "}" | "[" <bnf> "]" ] }
  * <expr> ::= <term> ("<" | ">" | "==" | "!=" | "<=" | ">=") (<term> | <float>)
  * <guard> ::= <expr> { ("or" | "and") ["not"] ( <expr> | "("<expr>")" ) }
  * <term> ::= <name> "(" <indexed> ")"
  * \endcode
  *
  *
  * Алгоритм проеобразования выражений guard в RPN-программу.

  * - Пока есть ещё символы для чтения:
  *      - Читаем очередной символ.
  *      - Если символ является числом, добавить его к выходной строке.
  *      - Если символ является символом функции, помещаем его в стек.
  *      - Если символ является открывающей скобкой, помещаем его в стек.
  *      - Если символ является закрывающей скобкой:
  *            - До тех пор, пока верхним элементом стека не станет открывающаяся скобка, выталкиваем элементы
  *              из стека в выходную строку. При этом открывающаяся скобка удаляется из стека, но в выходную
  *              строку не добавляется. Если после этого шага на вершине стека оказывается символ функции,
  *              выталкиваем его в выходную строку. Если стек закончился раньше, чем мы встретили открывающуюся
  *              скобку, это означает, что в выражении либо неверно поставлен разделитель, либо несогласованы
  *              скобки.
  * - Если символ является оператором, о1, тогда:
  *     1. пока…
  *        … (если оператор o1 ассоциированный, либо лево-ассоциированный) приоритет o1 меньше либо
  *           равен приоритету оператора, находящегося на вершине стека…
  *        … (если оператор o1 право-ассоциированый) приоритет o1 меньше приоритета оператора,
  *           находящегося на вершине стека…
  *        … выталкиваем верхние элементы стека c большим либо равным приоритетом в выходную строку;
  *     2. помещаем оператор o1 в стек.
  * - Когда входная строка закончилась, вытолкнуть все символы из стека в выходную строку.
  *   В стеке должны были остаться только символы операторов; если это не так, значит в выражении
  *   несогласованы скобки.
  */
class FilePAT
{
public:
    //! Конструктор
    /*! \param fileName Имя файла, из которого необходимо выполнить загрузку
      * \param pat Набор шаблонов, в который необходимо добавить шаблоны из файла
      */
    FilePAT(std::string fileName = "", Patterns *pat = NULL) {
        loadFromFile(fileName, pat);
    }

    //! Загрузка из файла
    /*! \param fileName Имя файла, из которого необходимо выполнить загрузку
      * \param pat Набор шаблонов, в который необходимо добавить шаблоны из файла
      * \throw EParse
      */
    void loadFromFile(std::string fileName, Patterns *pat);
};

/*@}*/

} // namespace

#endif // FILEPAT_H
