/* Author: Vladimir Belikov
 *
 * This file is part of Fractal Library.
 *
 * Fractal Library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Fractal Library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Fractal Libray.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef HYPERTREE_H
#define HYPERTREE_H

#include <vector>
#include <list>
#include <map>
#include <algorithm>
#include "Exceptions.h"

namespace FL {

/*! \addtogroup FLAlgorithm
  */
/*@{*/

// forwards
template <typename Node> class NodeGroup;
template <typename Node> class HyperTreeSet;

/*! \class EmptyNode
  * \brief Node without fields. Usefull for debugiin of HyperTree
  */
class EmptyNode
{
public:
};

/*! \class HyperTree
  * \brief Compact storage for set of trees with intersections
  *
  * Trees G1(V1, E1), ..., Gn(Vn, En) have intersection if
  * for each i, j: Vi union Vj is not empty and may be Ei union Ej is not empty
  *
  * Common nodes group of several trees stored in single shared block.
  * That means that physicaly there is only one copy of every shared group of nodes.
  * It serves to minimize memory usage and for fast tree coping. Procedure of
  * tree coping intensivly used in analyzers and fast tree coping is needed.
  *
  * \todo Dumping of rarely used groupes from RAM to disk
  * If you need some extra functionality - just inherite this class.
  */
template <typename Node>
class HyperTree
{
public:
    /*! \typedef Layer
      * \brief Any sequence of nodes
      *
      * It was made as list (not vector) because insertion could be frequent
      */
    typedef std::list<Node*> Layer;

    /*! \typedef ConstLayer
      * \brief Any constant sequence of constant nodes
      */
    typedef const Layer ConstLayer;

    /*! \typedef NodeGroupSet
      * \brief Vector of NodeGroup
      */
    typedef std::vector<NodeGroup<Node>*> NodeGroupSet;
public:
    //! Default constructor
    /*! \param treeSet If not NULL, tree will remember tree set it belongs to and
      * register in it. Additional statistics will be generated by this treeSet
      */

    HyperTree(HyperTreeSet<Node> *treeSet = NULL);
    //! Default destructor
    /*! Remove references from own and shared node groups.
      * It virtual for best inheriting
      */
    virtual ~HyperTree();

    //! Copy tree
    /*! Coping procedure is really fast - it takes about O(n),
      * where n is the number of shared groups of nodes plus one.
      * Own group of nodes of this tree becomes shared so it can't be changed anymore.
      * Instead this tree create new own group
      */
    void copyTo(HyperTree<Node> *tree);

    //! Add node
    /*! It's sad that virtual template member cannot be created, it would be
      * the best way to flexibility of adding. So a little bit glutched way was choosed:
      * class have non-virtual template addNode(Node *node) function and virtual non-template
      * trigger method onAddNode(void *node). May be some day better desision will be found :)
      * Anywhere children of HyperTree should override onAddNode method if they want
      * extent standart behaviour.
      */
    Node* addNode(Node *node)
    {
        if (node && onAddNode(node))
        {
            m_ownNodes->nodes().push_back(node);
            return node;
        }
        else
            return NULL;
    }

    //! Set parent of the node
    /*! \param node Node to set new parent
      * \param parent New parent of node
      */
    void setNodeParent(Node *node, Node *parent)
    {
        m_ownParents[node] = parent;
    }

    //! Get node's parent
    Node* nodeParent(Node *node)
    {
        typename std::map<Node*, Node*>::const_iterator
                i = m_ownParents.find(node);
        if (i != m_ownParents.end())
            return i->second;
        return NULL;
    }

    //! Clear tree
    void clear();

    //! Get treeSet that HyperTree belongs to
    /*! If tree don't belongs to any set, ETree exception will be thrown
      * \throws ETree
      */
    HyperTreeSet<Node>* treeSet()
    {
        if (m_treeSet)
            return m_treeSet;
        else
        {
            GError(GCritical, "HyperTree", -1, "Tree don't belongs to any set");
            return NULL;
        }
    }

    //! Get if tree belong to any set
    bool haveTreeSet()
    {
        return m_treeSet != NULL;
    }

protected:
    //! Triggered virtual function called every time node is added
    /*! \return true if node can be added, false otherwise
      * \sa addNode
      */
    virtual bool onAddNode(void *node)
    {
        return true;
    }

    //! Triggered virtual function called when some tree copied itself to this tree
    /*! \param original Tree that copy itself to this tree
      * \sa copyTo
      */
    virtual void onCopied(void *original)
    {
    }

    NodeGroupSet m_sharedNodes; //!< Shared groupes of nodes
    NodeGroup<Node> *m_ownNodes; //!< Group of nodes that currently owned only be this tree
    std::map<Node*, Node*> m_ownParents; //!< Parents of the own node
    HyperTreeSet<Node> *m_treeSet; //!< Tree set HyperTree belong to
};

/*! \class NodeGroup
  * \brief Group (set) of nodes wich can be shared by several trees.
  *
  * It use reference counter to know if group is still in use.
  * At this moment if tree use group it use all its nodes. If tree need some node
  * from group to be modified it must create new group, copy all nodes from shared group
  * to this new group and modify node it need to be. This is minor feature of
  * current share storage algorithm.
  *
  * If several trees use group, neither group nor its nodes can be modified.
  * Hovewer, if there is only one tree use group, it can modify anything.
  */
template <typename Node>
class NodeGroup {
public:
    //! Default constructor
    /*! Optionally can be specified treeSet parameter. It could be specified only once,
      * and some statistics about group will be provided for this set. Throught different tree
      * that uses this group can belong to different sets, information will be provided only
      * for this one set. This pparameter mostly usefull for debuging and in future
      * tree sets could be used as supervisor classes, so they will want some statistics.
      *
      * \param treeSet Set, that group belong to. If not NULL, some statistics
      * will be provided for treeSet
      */
    NodeGroup(HyperTreeSet<Node> *treeSet = NULL);

    //! Default destructor
    ~NodeGroup();

    //! Get constant nodes
    typename HyperTree<Node>::ConstLayer& cnodes() const
    {
        return m_nodes;
    }

    //! Get non-constant nodes. Only posible if there is only one or zero tree use the group
    /*! If there are more than one users, ETree exception will be thrown
      * \throws ETree
      */
    typename HyperTree<Node>::Layer& nodes()
    {
        if (m_refCount <= 1)
            return m_nodes;
        else
        {
            GError(GCritical, "HyperTree", -1, "Can't modify node group");
            return NULL;
        }
    }

    //! New tree share the group
    void addRef()
    {
        ++m_refCount;
        logg.debug("NodeGroup: AddRef ") << m_refCount;
    }

    //! Some tree don't need this group anymore
    /*! If reference count becomes zero, group will destroy itself
      */
    void remRef()
    {
        logg.debug("NodeGroup: RemRef ") << m_refCount-1;
        if (--m_refCount == 0)
            delete this;
    }

    //! Check if own nodes will be deleted in destructor
    bool clearOnDelete()
    {
        return m_clearOnDelete;
    }

    //! Set if own nodes will be deleted in destructor
    void setClearOnDelete(bool value)
    {
        m_clearOnDelete = value;
    }
private:
    typename HyperTree<Node>::Layer m_nodes; //!< Nodes of group
    int m_refCount; //!< Group user count
    HyperTreeSet<Node> *m_treeSet; //!< Tree set that holds this group (unnecessery, used for statistics)
    bool m_clearOnDelete; //!< Clear own nodes in destructor
};


/*! \class HyperTreeSet
  * \brief Simple storage of HyperTree
  *
  * In fact it is not set, it's sequence, but who cares.
  * It adapted for HyperTrees and a little bit convenient for them than std::vector
  */
template <typename Node>
class HyperTreeSet
{
public:
    //! Get the tree
    HyperTree<Node>* operator[](int index)
    {
        return trees[index];
    }


    //! Destructor
    ~HyperTreeSet()
    {
        clear();
    }

    //! Add new tree. Shortcut for trees.push_back(tree)
    void add(HyperTree<Node> *tree)
    {
        trees.push_back(tree);
    }

    //! Shortcut to trees.size()
    int size()
    {
        return trees.size();
    }

    //! Clear collection of trees and delete every tree
    void clear()
    {
        typename std::vector<HyperTree<Node>*>::iterator tree;
        for (tree = trees.begin(); tree != trees.end(); ++tree)
            delete *tree;
        trees.clear();
    }


    //! All the trees
    std::vector<HyperTree<Node>*> trees;

    //! Created node groups (only registered groups)
    const typename HyperTree<Node>::NodeGroupSet& nodeGroups()
    {
        return m_nodeGroups;
    }

    //! Compute average amount of memory used by registered groups
    /*! In fact it calculates only memory used by nodes, but it's quite exact
      */
    unsigned int bytesUsed()
    {
        unsigned int result = 0;
        typename HyperTree<Node>::NodeGroupSet::const_iterator g;

        for (g = m_nodeGroups.begin(); g != m_nodeGroups.end(); ++g)
        {
            result += (*g)->cnodes().size() * ( sizeof(Node) + sizeof(Node*) );
        }
        return result;
    }

    friend class NodeGroup<Node>;
private:
    //! Register new node group. Used for statistic collection and debuging
    void registerNodeGroup(NodeGroup<Node>* group)
    {
        typename HyperTree<Node>::NodeGroupSet::iterator g =
                std::find(m_nodeGroups.begin(), m_nodeGroups.end(), group);
        if (g == m_nodeGroups.end())
            m_nodeGroups.push_back(group);
    }

    //! Unregister new node group. Used for statistic collection and debuging
    void unregisterNodeGroup(NodeGroup<Node> *group)
    {
        typename HyperTree<Node>::NodeGroupSet::iterator g =
                std::find(m_nodeGroups.begin(), m_nodeGroups.end(), group);
        if (g != m_nodeGroups.end())
            m_nodeGroups.erase(g);
    }

    //! Registered node groups
    typename HyperTree<Node>::NodeGroupSet m_nodeGroups;
};

/*@}*/

/***** IMPLEMENTATION SECTION *****/

/*** NodeGroup ***/

template <typename Node>
NodeGroup<Node>::NodeGroup(HyperTreeSet<Node> *treeSet):
    m_refCount(0), m_treeSet(treeSet)
{
    // register group to share statistics
    if (m_treeSet)
        m_treeSet->registerNodeGroup(this);
    m_clearOnDelete = true;
}

template <typename Node>
NodeGroup<Node>::~NodeGroup()
{
    if (m_treeSet)
        m_treeSet->unregisterNodeGroup(this);

    // it must be an error to delete such group
    if (m_refCount != 0)
        GError(GCritical, "HyperTree", -1,
               "Node group destroyed through there is references to it");

    // real application of ClearOnDelete
    if (m_clearOnDelete)
    {
        typename HyperTree<Node>::Layer::iterator node;
        for (node = m_nodes.begin(); node != m_nodes.end(); ++node)
            delete *node;
    }
    m_nodes.clear();
}

/*** HyperTree ***/

template <typename Node>
HyperTree<Node>::HyperTree(HyperTreeSet<Node> *treeSet)
    : m_treeSet(treeSet)
{
    m_ownNodes = new NodeGroup<Node>(m_treeSet);
    m_ownNodes->addRef();
    logg.debug("Hypertree created");
}

template <typename Node>
HyperTree<Node>::~HyperTree()
{
    logg.debug("Hypertree destroyed");
    m_ownNodes->remRef();    
    typename NodeGroupSet::iterator group;
    for_each_(group, m_sharedNodes)
        (*group)->remRef();
}

template <typename Node>
void HyperTree<Node>::copyTo(HyperTree<Node> *tree)
{
    // Make own group shared, create new own group
    m_sharedNodes.push_back(m_ownNodes);
    m_ownNodes->addRef();
    m_ownNodes = new NodeGroup<Node>(m_treeSet);
    m_ownNodes->addRef();

    // Copy tree data
    tree->clear();
    typename NodeGroupSet::iterator group;
    for_each_(group, m_sharedNodes)
    {
        tree->m_sharedNodes.push_back(*group);
        (*group)->addRef();
    }
    tree->onCopied(this);
    logg.debug("Hypertree copied");
}

template <typename Node>
void HyperTree<Node>::clear()
{
    if (m_ownNodes)
    {
        m_ownNodes->remRef();
        m_ownNodes = new NodeGroup<Node>(m_treeSet);
        m_ownNodes->addRef();
    }
    typename NodeGroupSet::iterator group;
    for_each_(group, m_sharedNodes)
        (*group)->remRef();
}

/*** OPERATORS ***/

//! Shortcut operator
template <typename Node>
inline void operator+=(typename HyperTree<Node>::Layer::const_iterator &i, int n)
{
    while (n > 0)
        ++i, --n;
}

//! Shortcut operator
template <typename Node>
inline void operator+=(typename HyperTree<Node>::ConstLayer::const_iterator &i, int n)
{
    while (n > 0)
        ++i, --n;
}

//! Shortcut operator
template <typename Node>
inline typename HyperTree<Node>::ConstLayer::const_iterator
    operator+( const typename HyperTree<Node>::ConstLayer::const_iterator &i, int n )
{
    typename HyperTree<Node>::ConstLayer::const_iterator result = i;
    if (n >= 0)
        while (n > 0)
            ++result, --n;
    else
        while (n < 0)
            --result, ++n;
    return result;
}

//! Shortcut operator
template <typename Node>
inline typename HyperTree<Node>::ConstLayer::const_iterator
    operator-( const typename HyperTree<Node>::ConstLayer::const_iterator &i, int n )
{
    typename HyperTree<Node>::ConstLayer::const_iterator result = i;
    if (n >= 0)
        while (n > 0)
            --result, --n;
    else
        while (n < 0)
            ++result, ++n;
    return result;
}


} // namespace

#endif // HYPERTREE_H
